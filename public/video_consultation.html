<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Consultation - DoctorPod</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f172a;
      color: white;
      height: 100vh;
      overflow: hidden;
    }

    .video-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      padding: 1rem;
      height: calc(100vh - 80px);
    }

    .video-box {
      position: relative;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .video-box video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-label {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .video-placeholder {
      text-align: center;
      color: #64748b;
    }

    .video-placeholder-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
    }

    .controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1e293b;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      border-top: 1px solid #334155;
    }

    .control-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      transition: all 0.2s;
    }

    .control-btn:hover {
      transform: scale(1.1);
    }

    .btn-mute {
      background: #475569;
      color: white;
    }

    .btn-mute.active {
      background: #ef4444;
    }

    .btn-camera {
      background: #475569;
      color: white;
    }

    .btn-camera.active {
      background: #ef4444;
    }

    .btn-end {
      background: #ef4444;
      color: white;
      width: 64px;
      height: 64px;
    }

    .connection-status {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.75rem 1.25rem;
      border-radius: 8px;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
      animation: blink 1s infinite;
    }

    .status-indicator.connected {
      background: #10b981;
      animation: none;
    }

    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.3; }
    }

    @media (max-width: 768px) {
      .video-container {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="connection-status">
    <span class="status-indicator" id="statusIndicator"></span>
    <span id="statusText">Connecting...</span>
  </div>

  <div class="video-container">
    <div class="video-box">
      <div class="video-label" id="localLabel">You</div>
      <video id="localVideo" autoplay muted playsinline></video>
    </div>

    <div class="video-box">
      <div class="video-label" id="remoteLabel">Waiting...</div>
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="video-placeholder" id="remotePlaceholder">
        <div class="video-placeholder-icon">ðŸ‘¤</div>
        <div id="placeholderText">Waiting for other party to join...</div>
      </div>
    </div>
  </div>

  <div class="controls">
    <button class="control-btn btn-mute" id="muteBtn" title="Mute/Unmute">
      ðŸŽ¤
    </button>
    <button class="control-btn btn-camera" id="cameraBtn" title="Camera On/Off">
      ðŸ“¹
    </button>
    <button class="control-btn btn-end" id="endBtn" title="End Call">
      ðŸ“ž
    </button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const appointmentId = urlParams.get('appointment_id');
    const doctorId = urlParams.get('doctor_id');
    const patientName = urlParams.get('patient_name');
    const doctorName = urlParams.get('doctor_name');
    const role = urlParams.get('role') || 'doctor'; // Default to doctor for backward compatibility

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const remotePlaceholder = document.getElementById('remotePlaceholder');
    const localLabel = document.getElementById('localLabel');
    const remoteLabel = document.getElementById('remoteLabel');
    const placeholderText = document.getElementById('placeholderText');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const muteBtn = document.getElementById('muteBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const endBtn = document.getElementById('endBtn');

    let localStream = null;
    let peerConnection = null;
    let socket = null;
    let isMuted = false;
    let isCameraOff = false;
    
    const isDoctor = role === 'doctor';
    const isPatient = role === 'patient';

    // Set up role-based labels
    if (isDoctor) {
      localLabel.textContent = 'You (Doctor)';
      remoteLabel.textContent = patientName || 'Patient';
      placeholderText.textContent = 'Waiting for patient to join...';
    } else {
      localLabel.textContent = 'You (Patient)';
      remoteLabel.textContent = doctorName ? `Dr. ${doctorName}` : 'Doctor';
      placeholderText.textContent = 'Waiting for doctor...';
    }

    // ICE servers for STUN/TURN
    const iceServers = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // Initialize
    async function init() {
      try {
        // Get local media
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        
        localVideo.srcObject = localStream;
        
        // Connect to signaling server
        socket = io();
        
        socket.on('connect', () => {
          console.log('Connected to signaling server');
          statusText.textContent = 'Connected';
          statusIndicator.classList.add('connected');
          
          // Join room with role
          socket.emit('join-video-room', {
            room: appointmentId,
            role: role,
            doctorId: doctorId
          });
        });

        // === DOCTOR ROLE: Wait for patient, then create offer ===
        if (isDoctor) {
          socket.on('patient-joined', async () => {
            console.log('Patient joined, creating offer');
            remotePlaceholder.style.display = 'none';
            await createPeerConnection();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit('offer', { room: appointmentId, offer });
          });

          socket.on('answer', async (answer) => {
            console.log('Received answer from patient');
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
          });

          socket.on('patient-left', () => {
            console.log('Patient left the call');
            remotePlaceholder.style.display = 'block';
            remoteVideo.srcObject = null;
            if (peerConnection) {
              peerConnection.close();
              peerConnection = null;
            }
          });
        }

        // === PATIENT ROLE: Wait for offer from doctor ===
        if (isPatient) {
          socket.on('offer', async (offer) => {
            console.log('Received offer from doctor');
            remotePlaceholder.style.display = 'none';
            await createPeerConnection();
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('answer', { room: appointmentId, answer });
          });

          socket.on('doctor-left', () => {
            console.log('Doctor left the call');
            alert('Doctor has ended the consultation');
            endCall();
          });
        }

        // === COMMON: ICE candidates ===
        socket.on('ice-candidate', async (candidate) => {
          if (peerConnection) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          }
        });

      } catch (error) {
        console.error('Failed to get media:', error);
        
        // Check if it's a permissions/security issue
        let errorMsg = 'âŒ Could not access camera/microphone.\n\n';
        
        if (error.name === 'NotAllowedError') {
          errorMsg += 'Please allow camera and microphone permissions in your browser settings.';
        } else if (error.name === 'NotFoundError') {
          errorMsg += 'No camera or microphone found on your device.';
        } else if (error.name === 'NotSupportedError' || window.location.protocol === 'http:') {
          errorMsg += 'âš ï¸ HTTPS Required for Mobile!\n\n';
          errorMsg += 'Video calls require HTTPS on mobile devices.\n\n';
          errorMsg += 'Options:\n';
          errorMsg += '1. Deploy to Render (automatic HTTPS)\n';
          errorMsg += '2. Use desktop/laptop for localhost testing\n';
          errorMsg += '3. Set up local HTTPS with ngrok';
        } else {
          errorMsg += 'Error: ' + (error.message || 'Unknown error');
        }
        
        alert(errorMsg);
        goBack();
      }
    }

    async function createPeerConnection() {
      peerConnection = new RTCPeerConnection(iceServers);

      // Add local tracks
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Handle remote tracks
      peerConnection.ontrack = (event) => {
        console.log('Received remote track');
        remoteVideo.srcObject = event.streams[0];
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('ice-candidate', {
            room: appointmentId,
            candidate: event.candidate
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          statusText.textContent = 'Call Active';
        } else if (peerConnection.connectionState === 'disconnected') {
          statusText.textContent = 'Disconnected';
          statusIndicator.classList.remove('connected');
        }
      };
    }

    // Controls
    muteBtn.addEventListener('click', () => {
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      muteBtn.classList.toggle('active', isMuted);
      muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
    });

    cameraBtn.addEventListener('click', () => {
      isCameraOff = !isCameraOff;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = !isCameraOff;
      });
      cameraBtn.classList.toggle('active', isCameraOff);
      cameraBtn.textContent = isCameraOff ? 'ðŸ“µ' : 'ðŸ“¹';
    });

    endBtn.addEventListener('click', () => {
      if (confirm('End video consultation?')) {
        endCall();
      }
    });

    function endCall() {
      if (socket) {
        socket.emit('leave-room', { room: appointmentId, role: role });
        socket.disconnect();
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      
      if (peerConnection) {
        peerConnection.close();
      }
      
      goBack();
    }

    function goBack() {
      // Navigate based on role
      if (isDoctor) {
        window.close();
        // If window.close doesn't work (wasn't opened by script), redirect
        setTimeout(() => {
          window.location.href = '/doctor_dashboard.html';
        }, 100);
      } else {
        window.location.href = '/check_booking.html';
      }
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      endCall();
    });

    // Start
    init();
  </script>
</body>
</html>
